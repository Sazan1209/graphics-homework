#version 450
#extension GL_GOOGLE_include_directive : require

#include "resolve.glsl"
#include "utils.glsl"

layout(local_size_x = 32, local_size_y = 32) in;


layout(binding = 0, rgba8) readonly uniform image2D albedoMetallic;
layout(binding = 1, rgba8_snorm) restrict readonly uniform image2D normalOcclusion;
layout(binding = 2, rgba8) readonly uniform image2D emissiveRoughness;
layout(binding = 3) uniform sampler2D depths;

layout(binding = 4, rgba8) writeonly uniform image2D color;
layout(binding = 5, r32f) writeonly uniform image2D brightness;

layout(binding = 6, std430) buffer resolve_point_lightsbrightness
{
  PointLight lights[];
};

layout(binding = 7, std140) readonly restrict uniform resolve_sunlight
{
  Sunlight sunlight;

  vec3 skyColor;
  float near;

  mat4 mView;

  float far;
  float tanFov;
  float attenuationCoef;
};

// Sunlight(vec3(1.0 / 2, -sqrt(3.0) / 2.0, 0), 0.0, vec3(1, 1, 1), 0.05);
// sunlight.strength * vec3(135, 206, 235) / 255.0;
// 1.0
// 0.005

float pow5(float val){
  float tmp = val * val;
  tmp *= tmp;
  return tmp * val;
}

float pow2(float val){
  return val * val;
}

float mixSqrtAdd(float val, float coef){
  return val + sqrt(coef + (1 - coef) * val * val);
}

float heaviside(float val){
  return step(0.0, val);
}

float specularBRDF(vec3 v, vec3 l, vec3 n, vec3 h, float vDotH, float alpha){
  float lDotH = dot(l, h);
  float nDotL = abs(dot(n, l));
  float nDotV = abs(dot(n, v));
  float nDotH = dot(n, h);
  alpha = alpha * alpha;

  float visibility = heaviside(lDotH) * heaviside(vDotH);
  visibility /= mixSqrtAdd(nDotL, alpha) * mixSqrtAdd(nDotV, alpha) + 0.001;

  float distribution = alpha * heaviside(nDotH);
  distribution /= pow2(nDotH * nDotH * (alpha - 1.0) + 1.0) * PI + 0.001;

  return visibility * distribution;
}

// v = pToEye
// l = pToLight
// n = normal
vec3 BRDF(vec3 v, vec3 l, vec3 n, float metallic, float roughness, vec3 albedo){
  vec3 h = normalize(l + v);
  vec3 c_diff = mix(albedo.rgb, vec3(0.0), metallic);
  vec3 f0 = mix(vec3(0.04), albedo.rgb, metallic);

  float alpha = pow2(roughness);
  float vDotH = dot(v, h);
  vec3 F = f0 + (1 - f0) * pow5(1 - abs(vDotH));
  vec3 f_diffuse = (1 - F) * (1 / PI) * c_diff;
  vec3 f_specular = F * specularBRDF(v, l, n, h, vDotH, alpha);

  return f_diffuse + f_specular;
}

void storeLight(vec3 light, ivec2 coord){
  float brightnessVal = dot(light, lumVec);
  vec3 colorVal = light / brightnessVal;
  imageStore(color, coord, vec4(fromLinear(colorVal), 1.0));
  imageStore(brightness, coord, vec4(brightnessVal));
}

void main()
{
  ivec2 resolution = imageSize(albedoMetallic);
  if (any(greaterThan(gl_GlobalInvocationID.xy, resolution)))
  {
    return;
  }

  ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

  float depth = texelFetch(depths, coord, 0).x;
  if (depth == 1.0)
  {
    storeLight(skyColor * sunlight.strength / 5.0, coord);
    return;
  }

  float aspect = float(resolution.x) / float(resolution.y);

  vec3 pos;

  vec2 fragCoord = (vec2(gl_GlobalInvocationID.xy) + 0.5) * 2.0 / vec2(resolution) - 1.0;
  pos.z = near / (1.0 - ((far - near) / far) * depth);
  pos.y = -tanFov * pos.z * fragCoord.y;
  pos.x = -tanFov * pos.z * aspect * fragCoord.x;

  vec3 normal;
  float occlusion;
  {
    vec4 tmp = imageLoad(normalOcclusion, coord);
    normal = mat3(mView) * tmp.xyz;
    occlusion = tmp.w;
  }

  vec3 albedo;
  float metallic;
  {
    vec4 tmp = imageLoad(albedoMetallic, coord);
    albedo = toLinear(tmp.xyz);
    metallic = tmp.w;
  }

  vec3 emissive;
  float roughness;
  {
    vec4 tmp = imageLoad(emissiveRoughness, coord);
    emissive = toLinear(tmp.xyz);
    roughness = tmp.w;
  }

  vec3 light = vec3(0);
  vec3 eyeDir = normalize(-pos);

  for (int i = 0; i < lights.length(); ++i)
  {
    vec3 lightPos = (mView * vec4(lights[i].pos, 1.0)).xyz;
    float lightDist = distance(pos, lightPos);
    float attenuation = 1.0 / (1.0 + attenuationCoef * lightDist * lightDist);

    vec3 lightDir = normalize(lightPos - pos);
    vec3 bdrf = BRDF(eyeDir, lightDir, normal, metallic, roughness, albedo);

    vec3 L = lights[i].color * lights[i].strength * attenuation;

    light += bdrf * L * max(dot(normal, lightDir), 0.0);
  }

  {
    vec3 lightDir = -mat3(mView) * sunlight.dir;

    vec3 L = sunlight.color * sunlight.strength;
    vec3 bdrf = BRDF(eyeDir, lightDir, normal, metallic, roughness, albedo);

    light += L * bdrf * max(dot(normal, lightDir), 0.0);
  }

  {
    light += sunlight.ambient * sunlight.strength * occlusion * albedo;
  }

  {
    light += emissive;
  }

  storeLight(light, coord);
}

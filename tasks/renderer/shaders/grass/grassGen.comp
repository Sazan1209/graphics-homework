#version 430

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 64) in;

#include "grass.glsl"

// grass blade

// POR - point of origin
// xInd, yInd

layout(push_constant, std430) uniform grassvert_pc
{
  mat4 VfW;
  vec3 eyePos;
  float maxRandomOffset;
  uint ring;
  float tilt;
  float grassHeight;
};

// grass position and facing generation
// culling
// height generation
//

layout(binding = 0) uniform sampler2D perlinNoise;
layout(binding = 1, std430) restrict writeonly buffer grass_gen_buf1
{
  GrassInstanceData blades[];
};
layout(binding = 2, std430) buffer grass_gen_buf2
{
  GrassDrawCallData drawcall;
};

// Model coordinates from world
vec2 getMfW(in vec2 wPos)
{
  wPos -= centerCoordWorld.xz;
  wPos.y = -wPos.y;
  wPos += centerCoordModel.xz;
  return wPos;
}

vec3 getMfW(in vec3 wPos)
{
  wPos.xz = getMfW(wPos.xz);
  return wPos;
}

// The 00 coord for the grass render square centered on the player
ivec2 findFirstGrassID(vec2 mStartPos)
{
  const int step = (1 << ring);
  ivec2 iStartPos = ivec2((mStartPos / terrainSize) * totalGrassCount / float(step)) << ring;
  ivec2 cornerXY = max(iStartPos - (ivec2(centerGrassCount / 2.0) << ring), ivec2(0));
  return cornerXY;
}

// texture coords from model
vec2 getTfM(vec2 mPos)
{
  return mPos / terrainSize;
}

vec2 getMfI(ivec2 iPos)
{
  return vec2(iPos) / grassPerMeter;
}

vec3 getWfM(vec3 mPos)
{
  mPos -= centerCoordModel;
  mPos.z = -mPos.z;
  mPos += centerCoordWorld;
  return mPos;
}

ivec2 getRfIndex(int index)
{
  ivec2 iGrassCount = ivec2(centerGrassCount);

  if (ring != 0)
  {
    int add = index - (iGrassCount.y + 1) * iGrassCount.x / 4;
    add = max(add, 0);
    int w_half = iGrassCount.x / 2;
    add = (add + (w_half - 1)) / w_half;
    add *= w_half;
    add = min((iGrassCount.x * iGrassCount.y) / 4, add);
    index += add;
  }
  return ivec2(index % iGrassCount.x, index / iGrassCount.x);
}

void main()
{
  const int index = int(gl_GlobalInvocationID.x);

  vec2 mEye = getMfW(eyePos.xz);

  ivec2 iPos = findFirstGrassID(mEye) + (getRfIndex(index) << ring);

  uint n = (iPos.y * 7) ^ (iPos.x);
  vec2 jitter = (vec2(rand(n), rand(n)) - 0.5) * maxRandomOffset;

  vec2 mPos2D = getMfI(iPos) + jitter;
  vec2 tPos = getTfM(mPos2D);
  float height = texture(perlinNoise, tPos).x;

  vec3 mPos3D = vec3(mPos2D, height).xzy;
  vec3 wPos3D = getWfM(mPos3D);

  if (index == 0){
    drawcall.comm.vertexCount = 15;
  }

  GrassInstanceData blade;
  blade.pos = wPos3D;
  blade.facing = rand(n) * 2.0 * PI;
  blade.hash = n;

  {
    bool curr = false;
    float angle = tilt * PI / 2.0;
    vec2 facing = vec2(sin(blade.facing), cos(blade.facing));
    vec3 offset = vec3(facing * sin(angle), cos(angle)).xzy * grassHeight;

    vec4 p = VfW * vec4(wPos3D, 1.0);
    p /= p.w + grassHeight;
    curr = curr || all(greaterThan(p.xyz, vec3(-1, -1, 0))) && all(lessThan(p.xyz, vec3(1, 1, 1)));

    p = VfW * vec4(wPos3D + offset, 1.0);
    p /= p.w + grassHeight;
    curr = curr || all(greaterThan(p.xyz, vec3(-1, -1, 0))) && all(lessThan(p.xyz, vec3(1, 1, 1)));

    if (!curr)
    {
      return;
    }
  }

  uint writeIndex = atomicAdd(drawcall.comm.instanceCount, 1);
  blades[writeIndex] = blade;
}

#version 430

#extension GL_GOOGLE_include_directive : require

#include "grass.glsl"

// grass blade

// POR - point of origin
// xInd, yInd

layout(push_constant, std430) uniform grassvert_pc
{
  mat4 VfW;
  vec3 eyePos;
  float maxJitter;
};

// grass position and facing generation
// culling
// height generation
//

layout(binding = 0) uniform sampler2D perlinNoise;
layout(binding = 1, std430) restrict writeonly buffer grass_gen_buf1
{
  GrassInstanceData blades[];
};

// Model coordinates from world
vec2 getMfW(in vec2 wPos){
  wPos -= centerCoordWorld.xz;
  wPos.y = -wPos.y;
  wPos += centerCoordModel.xz;
  return wPos;
}

vec3 getMfW(in vec3 wPos){
  wPos.xz = getMfW(wPos.xz);
  return wPos;
}

// The 00 coord for the grass render square centered on the player
ivec2 findFirstGrassID(vec2 mStartPos){
  ivec2 iStartPos = ivec2((mStartPos / terrainSize) * totalGrassCount);
  ivec2 cornerXY = max(iStartPos - ivec2(drawnGrassCount / 2.0), ivec2(0));
  return cornerXY;
}

// texture coords from model
vec2 getTfM(vec2 mPos){
  return mPos / terrainSize;
}

vec2 getMfI(ivec2 iPos){
  return vec2(iPos) / grassPerMeter;
}

vec3 getWfM(vec3 mPos){
  mPos -= centerCoordModel;
  mPos.z = -mPos.z;
  mPos += centerCoordWorld;
  return mPos;
}

void main(){
  vec2 mEye = getMfW(eyePos.xz);
  ivec2 iPos = findFirstGrassID(mEye) + ivec2(gl_GlobalInvocationID.xy);

  const uint index =
    gl_GlobalInvocationID.y * gl_NumWorkGroups.x +
    gl_GlobalInvocationID.x;
  uint n = (iPos.y * 7) ^ (iPos.x);
  vec2 jitter = (vec2(rand(n), rand(n)) - 0.5) * maxJitter;

  vec2 mPos2D = getMfI(iPos) + jitter;
  vec2 tPos = getTfM(mPos2D);
  float height = texture(perlinNoise, tPos).x;



  vec3 mPos3D = vec3(mPos2D, height).xzy;
  vec3 wPos3D = getWfM(mPos3D);

  blades[index].pos = wPos3D;
  blades[index].facing = rand(n) * 2.0 * PI;
  blades[index].hash = n;
}
